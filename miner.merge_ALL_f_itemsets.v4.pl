#!/usr/bin/perl -w
# MGEL
# Surya Saha 4/01/07
# reading 5 noise itemset files and real itemset generated by m.out2f_itemsets
# writing out the real itemsets along with the with 
# Diff occurences = occurences - random occurences
# Diff Conf = Occ Conf - Random Conf
# NOTE: If noise>real occurences, then a 0 is recorded
# NOTE: If noise conf>real Conf, then a 0.00 is recorded

# OUTPUT:
# fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Strand, Category

# v2 : 06/27/07
# v2 : Changed output to F1 relation F2 style
# OUTPUT:
# fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Strand, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen
# v2 : Fixed divide by 0 error for Rand coincidence numbers

# v3 : Changed the scoring function to fam1 from min(|fam1|,|fam2|). 
# v3 : Printing output to different files for each strand

# v4 : Adapt script to read the config file to record stats accordingly

my ($ver);
$ver="4.0";


# use strict;
use warnings;
use POSIX;

# #fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Strand, Category
# R=15	4	259	R=15	4	259	3	+	u1
#0	1	2	3	4	5	6	7	8

unless (@ARGV == 7){
	print "USAGE: $0 <input real f_itemsets file> <input noise f_itemsets file 1> <input noise f_itemsets file 2> <input noise f_itemsets file 3> <input noise f_itemsets file 4> <input noise f_itemsets file 5> <relations config file>\n";
	exit;
}

my ($ifname,$rec,@temp,@stats,@merged_table,@real_table,%rels_stats,
%noise_hash_1,%noise_hash_2,%noise_hash_3,%noise_hash_4,%noise_hash_5, %temphash,$ctr,$i,$j,$k,$user_t,$system_t,$cuser_t,$csystem_t);

$ifname=$ARGV[0];
chomp $ifname;
unless(open(INFILEREALDATA,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

#slurping in the whole real itemset file
while($rec=<INFILEREALDATA>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	push @real_table, [split(' ',$rec)];
}
close (INFILEREALDATA);

unless(open(OUTFILEDATAPOS,">$ifname.merged.f_itemsets.pos.tab")){print "not able to open ".$ifname."merged.f_itemsets.pos.tab \n\n";exit;}
unless(open(OUTFILEDATANEG,">$ifname.merged.f_itemsets.neg.tab")){print "not able to open ".$ifname."merged.f_itemsets.neg.tab \n\n";exit;}
unless(open(OUTFILEDATABOTH,">$ifname.merged.f_itemsets.both.tab")){print "not able to open ".$ifname."merged.f_itemsets.both.tab \n\n";exit;}
unless(open(OUTFILESTATS,">$ifname.merged.f_itemsets.stats.tab")){print "not able to open ".$ifname."merged.f_itemsets.stats.tab \n\n";exit;}

$ifname=$ARGV[1];
chomp $ifname;
unless(open(INFILENOISEDATA_1,$ifname)){print "not able to open ".$ifname."\n\n";exit;}
# slurping in the whole noise 1 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_1>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_1{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}
close (INFILENOISEDATA_1);


$ifname=$ARGV[2];
chomp $ifname;
unless(open(INFILENOISEDATA_2,$ifname)){print "not able to open ".$ifname."\n\n";exit;}
# slurping in the whole noise 2 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_2>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_2{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}
close (INFILENOISEDATA_2);

$ifname=$ARGV[3];
chomp $ifname;
unless(open(INFILENOISEDATA_3,$ifname)){print "not able to open ".$ifname."\n\n";exit;}
# slurping in the whole noise 3 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_3>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_3{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}
close (INFILENOISEDATA_3);

$ifname=$ARGV[4];
chomp $ifname;
unless(open(INFILENOISEDATA_4,$ifname)){print "not able to open ".$ifname."\n\n";exit;}
# slurping in the whole noise 4 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_4>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_4{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}
close (INFILENOISEDATA_4);

$ifname=$ARGV[5];
chomp $ifname;
unless(open(INFILENOISEDATA_5,$ifname)){print "not able to open ".$ifname."\n\n";exit;}
# slurping in the whole noise 5 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_5>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_5{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}
close (INFILENOISEDATA_5);

# READ IN CONFIG FILE
# #Dir	Rel	Rng Strt	Rng End	Reci Rel
# U	u1	0	500	d1
# U	u2	500	1000	d2
$ifname=$ARGV[6];
chomp $ifname;
unless(open(INFILERELCONFIG,$ifname)){print "not able to open ".$ifname."\n\n";exit;}
# put the rel names data into a hash as keys
# total, count and conf will be stored in the value array
# %rels_stats :Strand rel => rel count, total count , total conf values
# hash value points to an array with 3 elements
while($rec=<INFILERELCONFIG>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	# intializing rel count, total count and total conf values
	# for each strand
	
	$rels_stats{"+ $temp[1]"}=[0,0,0];# init for Pos strand
	$rels_stats{"C $temp[1]"}=[0,0,0];# init for Comp strand
	$rels_stats{"B $temp[1]"}=[0,0,0];# init for Both (strand independent)
}
close (INFILERELCONFIG);

# add an IN and CONTAINS for each strand
# hash value points to an array with 3 elements
$rels_stats{"+ IN"}=[0,0,0]; $rels_stats{"+ CONT"}=[0,0,0];
$rels_stats{"C IN"}=[0,0,0]; $rels_stats{"C CONT"}=[0,0,0];
$rels_stats{"B IN"}=[0,0,0]; $rels_stats{"B CONT"}=[0,0,0];


sub round2{
	my ($num);
	$num=$_[0];
	$num=$num*100;
	$num=int($num);
	$num=$num/100;
	return $num;
}


$i=localtime();
# calculating time taken
($user_t,$system_t,$cuser_t,$csystem_t) = times;

print OUTFILEDATAPOS "\# Version: $ver\n";
print OUTFILEDATAPOS "\# Time: $i\n\n";
print OUTFILEDATAPOS "\# Runtime details after preparing all hashes:\n";
print OUTFILEDATAPOS "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILEDATAPOS "\# User time for process: ",ceil($user_t/60)," mins\n\n";

print OUTFILEDATANEG "\# Version: $ver\n";
print OUTFILEDATANEG "\# Time: $i\n\n";
print OUTFILEDATANEG "\# Runtime details after preparing all hashes:\n";
print OUTFILEDATANEG "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILEDATANEG "\# User time for process: ",ceil($user_t/60)," mins\n\n";

print OUTFILEDATABOTH "\# Version: $ver\n";
print OUTFILEDATABOTH "\# Time: $i\n\n";
print OUTFILEDATABOTH "\# Runtime details after preparing all hashes:\n";
print OUTFILEDATABOTH "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILEDATABOTH "\# User time for process: ",ceil($user_t/60)," mins\n\n";

print OUTFILESTATS "\# Version: $ver\n";
print OUTFILESTATS "\# Time: $i\n\n";
print OUTFILESTATS "\# Runtime details after preparing all hashes:\n";
print OUTFILESTATS "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILESTATS "\# User time for process: ",ceil($user_t/60)," mins\n\n";

print STDERR "\# Runtime details after preparing all hashes:\n";
print STDERR "\# System time for process: ",ceil($system_t/60)," mins\n";
print STDERR "\# User time for process: ",ceil($user_t/60)," mins\n\n";

#filling up the @merged_table array the merged file
# @real_table
# #fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Strand, Category
# R=15	4	259	R=15	4	259	3	+	u1
#0	1	2	3	4	5	6	7	8

# @merged_table:fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Occurence conf., Avg. Rand Coin., Avg. Rand Coin. conf., Diff, Diff conf., Strand, Category

$ctr=0;
foreach $i (@real_table){
	
	$merged_table[$ctr][0] = $i->[0];# fam1
	$merged_table[$ctr][1] = $i->[1];# fam1-count
	$merged_table[$ctr][2] = $i->[2];# fam1-avg len
	$merged_table[$ctr][3] = $i->[3];# fam2
	$merged_table[$ctr][4] = $i->[4];# fam2-count
	$merged_table[$ctr][5] = $i->[5];# fam2-avg len
	$merged_table[$ctr][6] = $i->[6];# Occurence count
	
	# calculating occ. conf
	$merged_table[$ctr][7] = &round2($i->[6]/$i->[1]);
	
	# Avg Rand Coin. count
	#get the noise data
	$j=$k=0;
	#check if the relation even exists in noise 1
	if (exists $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 2
	if (exists $noise_hash_2{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_2{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 3
	if (exists $noise_hash_3{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_3{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 4
	if (exists $noise_hash_4{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_4{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 5
	if (exists $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}
	
	# Random Coincidence
	if ($k>0){ # rand coin value found
		# Avg Rand Coin. count
		$merged_table[$ctr][8] = ceil($j/$k);
	
		# calculating Avg Rand Coin. conf
		$merged_table[$ctr][9] = &round2($merged_table[$ctr][8]/$i->[1]);
	}
	else{ # no rand coin values found
		$merged_table[$ctr][8] = 0;# Avg Rand Coin. count
		$merged_table[$ctr][9] = 0.00;# Avg Rand Coin. conf
	}
	
	#Diff
	#in order to store only >= 0 values
	if($i->[6] - $merged_table[$ctr][8] > -1) {
		$merged_table[$ctr][10] = $i->[6] - $merged_table[$ctr][8];
	}
	else{
		$merged_table[$ctr][10] = 0;
	}

	# calculating Diff. conf
	if ($merged_table[$ctr][10] > 0){# to avoid divide by 0
		$merged_table[$ctr][11] = &round2($merged_table[$ctr][10]/$i->[1]);
	}
	else{
		$merged_table[$ctr][11] = 0.00;# Diff. conf
	}
	
	$merged_table[$ctr][12] = $i->[7];# Strand
	$merged_table[$ctr][13] = $i->[8];# Category
	
	# get info for statistics
	# incrementing rel count
	# %rels_stats :Strand rel => rel count, total count , total conf values
	$rels_stats{"$merged_table[$ctr][12] $merged_table[$ctr][13]"}[0]++; 
	# incrementing tot count
	$rels_stats{"$merged_table[$ctr][12] $merged_table[$ctr][13]"}[1]+=$merged_table[$ctr][10]; 
	# incrementing tot conf
	$rels_stats{"$merged_table[$ctr][12] $merged_table[$ctr][13]"}[2]+=$merged_table[$ctr][11]; 

	$ctr++; # increment for next record
	if(($ctr % 10000) == 0){ print STDERR '.';}
}
print STDERR "\n\n";

#sort @merged_table on strand, difference conf, difference
# @merged_table:fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Occurence conf., Avg. Rand Coin., Avg. Rand Coin. conf., Diff, Diff conf., Strand, Category
@temp = sort {($a->[12] cmp $b->[12]) or ($b->[11] <=> $a->[11]) or ($b->[10] <=> $a->[10])} @merged_table;
@merged_table=@temp;


#print data to file
print OUTFILEDATAPOS "\#Output sorted on difference conf and difference\n\n";
print OUTFILEDATAPOS "\#fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Strand, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen\n";

print OUTFILEDATANEG "\#Output sorted on difference conf and difference\n\n";
print OUTFILEDATANEG "\#fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Strand, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen\n";

print OUTFILEDATABOTH "\#Output sorted on difference conf and difference\n\n";
print OUTFILEDATABOTH "\#fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Strand, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen\n";

foreach $i (@merged_table){
	if($i->[12] eq '+'){
		print OUTFILEDATAPOS "$i->[0]\t$i->[13]\t$i->[3]\t$i->[6]\t$i->[7]\t$i->[8]\t$i->[9]\t";
		print OUTFILEDATAPOS "$i->[10]\t$i->[11]\t$i->[12]\t$i->[0]\t$i->[1]\t$i->[2]\t$i->[3]\t";
		print OUTFILEDATAPOS "$i->[4]\t$i->[5]\n";
	}
	elsif($i->[12] eq 'C'){
		print OUTFILEDATANEG "$i->[0]\t$i->[13]\t$i->[3]\t$i->[6]\t$i->[7]\t$i->[8]\t$i->[9]\t";
		print OUTFILEDATANEG "$i->[10]\t$i->[11]\t$i->[12]\t$i->[0]\t$i->[1]\t$i->[2]\t$i->[3]\t";
		print OUTFILEDATANEG "$i->[4]\t$i->[5]\n";
	}
	elsif($i->[12] eq 'B'){
		print OUTFILEDATABOTH "$i->[0]\t$i->[13]\t$i->[3]\t$i->[6]\t$i->[7]\t$i->[8]\t$i->[9]\t";
		print OUTFILEDATABOTH "$i->[10]\t$i->[11]\t$i->[12]\t$i->[0]\t$i->[1]\t$i->[2]\t$i->[3]\t";
		print OUTFILEDATABOTH "$i->[4]\t$i->[5]\n";
	}
}

# calculating time taken
($user_t,$system_t,$cuser_t,$csystem_t) = times;
print OUTFILEDATAPOS "\n\# Runtime details after printing the relationships: \n";
print OUTFILEDATAPOS "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILEDATAPOS "\# User time for process: ",ceil($user_t/60)," mins\n";

print OUTFILEDATANEG "\n\# Runtime details after printing the relationships: \n";
print OUTFILEDATANEG "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILEDATANEG "\# User time for process: ",ceil($user_t/60)," mins\n";

print OUTFILEDATABOTH "\n\# Runtime details after printing the relationships: \n";
print OUTFILEDATABOTH "\# System time for process: ",ceil($system_t/60)," mins\n";
print OUTFILEDATABOTH "\# User time for process: ",ceil($user_t/60)," mins\n";

# Get all stats
# %rels_stats :Strand rel => rel count, total count , total conf values
@temp=();
$ctr=0;
while ( ($i,$j) = each %rels_stats){
	if ($j->[0]>0){# if count > 0
		$temp[$ctr][0]=$i; $temp[$ctr][1]=$j->[0]; $temp[$ctr][2]=$j->[1];
		$temp[$ctr][3]=ceil($j->[1]/$j->[0]); $temp[$ctr][4]=&round2($j->[2]);
		$temp[$ctr++][5]=&round2($j->[2]/$j->[0]);
	}
}

#sort @temp on count and avg conf
# @temp:Str Rel\tCnt\tFreqSum\tAvgFreq\tConfSum\tAvgConf\n";
@stats = sort {($b->[5] <=> $a->[5])} @temp;

#print stats to file
print OUTFILESTATS "NOTE: All avg. statistics are for the diff. counts and conf's\n\n";
# print OUTFILESTATS "Stats are not calculated for CONT rels because it is same as Within\n\n";
print OUTFILESTATS "Str Rel\tCnt\tFreqSum\tAvgFreq\tConfSum\tAvgConf\n";
foreach $i (@stats){
	print OUTFILESTATS "$i->[0]\t$i->[1]\t$i->[2]\t$i->[3]\t$i->[4]\t$i->[5]\n";
}
# calculating time taken
($user_t,$system_t,$cuser_t,$csystem_t) = times;
print OUTFILESTATS "\n\# Runtime details after printing the itemsets: \n";
print OUTFILESTATS "\# System time for process: ",ceil($system_t/60)," mins\n";
#print OUTFILEDATA "\# System time for children: $csystem_t\n";
print OUTFILESTATS "\# User time for process: ",ceil($user_t/60)," mins\n";
#print OUTFILEDATA "\# User time for children: $cuser_t\n";

close (OUTFILEDATAPOS);
close (OUTFILEDATANEG);
close (OUTFILEDATABOTH);
close (OUTFILESTATS);

print STDERR "\# Runtime details after printing the itemsets: \n";
print STDERR "\# System time for process: ",ceil($system_t/60)," mins\n";
print STDERR "\# User time for process: ",ceil($user_t/60)," mins\n";
# print STDERR "NOTE: Stats are not calculated for CONT rels because it is same as Within\n\n";



exit;
