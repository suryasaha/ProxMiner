#!/usr/bin/perl -w
# MGEL
# Surya Saha 4/01/07
# reading 5 noise itemset files and real itemset generated by m.out2f_itemsets
# writing out the real itemsets along with the with 
# Diff occurences = occurences - random occurences
# Diff Conf = Occ Conf - Random Conf
# NOTE: If noise>real occurences, then a 0 is recorded
# NOTE: If noise conf>real Conf, then a 0.00 is recorded

# OUTPUT:
#fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Avg Dist, Std Dev, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen

# v2 : 06/27/07
# v2 : Changed output to F1 relation F2 style
# OUTPUT:
# fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Strand, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen
# v2 : Fixed divide by 0 error for Rand coincidence numbers

# v3 : Changed the scoring function to fam1 from min(|fam1|,|fam2|). 
# v3 : Printing output to different files for each strand
# NOTE: Stats are not calculated for CONT rels because it will the same as Within

# Stage 1
# v1 : New version for stage1 f_itemset analysis (includes Avg dist and Std dev)
# v1 : Only 1 output file, old confidence measure of min(|fam1|,|fam2|).

my $ver=1.0;
use strict;
use warnings;
use POSIX;

# fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Category, Avg. dist., Std. dev.
# R=424	72	120	R=437	67	346	2	U	4512	2699.49
# 0	1	2	3	4	5	6	7	8	9

unless (@ARGV == 6){
	print "USAGE: $0 <input real f_itemsets file> <input noise f_itemsets file 1> <input noise f_itemsets file 2> <input noise f_itemsets file 3> <input noise f_itemsets file 4> <input noise f_itemsets file 5> \n";
	exit;
}


my ($ifname,$rec,@temp,@merged_table,@real_table,
%noise_hash_1,%noise_hash_2,%noise_hash_3,%noise_hash_4,%noise_hash_5, %temphash,@values,$ctr,$i,$j,$k,$user_t,$system_t,$cuser_t,$csystem_t,
$count_u,$total_u,$conf_u,$count_d,$total_d,$conf_d);

$ifname=$ARGV[0];
chomp $ifname;
unless(open(INFILEREALDATA,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

$ifname=$ARGV[1];
chomp $ifname;
unless(open(INFILENOISEDATA_1,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

$ifname=$ARGV[2];
chomp $ifname;
unless(open(INFILENOISEDATA_2,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

$ifname=$ARGV[3];
chomp $ifname;
unless(open(INFILENOISEDATA_3,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

$ifname=$ARGV[4];
chomp $ifname;
unless(open(INFILENOISEDATA_4,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

$ifname=$ARGV[5];
chomp $ifname;
unless(open(INFILENOISEDATA_5,$ifname)){print "not able to open ".$ifname."\n\n";exit;}

$ifname=$ARGV[0];
chomp $ifname;
unless(open(OUTFILEDATA,">$ifname.merged.f_itemsets.stg1.tab")){print "not able to open ".$ifname."merged.f_itemsets.stg1.tab\n\n";exit;}


unless(open(OUTFILESTATS,">$ifname.merged.f_itemsets.stats.tab")){print "not able to open ".$ifname."merged.f_itemsets.stats.tab \n\n";exit;}


sub round2{
	my ($num);
	$num=$_[0];
	$num=$num*100;
	$num=int($num);
	$num=$num/100;
	return $num;
}


#slurping in the whole real itemset file
while($rec=<INFILEREALDATA>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	push @real_table, [split(' ',$rec)];
}

# slurping in the whole noise 1 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_1>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_1{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}

# slurping in the whole noise 2 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_2>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_2{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}


# slurping in the whole noise 3 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_3>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_3{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}

# slurping in the whole noise 4 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_4>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_4{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}

# slurping in the whole noise 5 itemset file
# put the noise data into a hash
while($rec=<INFILENOISEDATA_5>){
	if($rec =~ /#/){next;}
	if(length ($rec) < 10){next;}#for avoiding last line
	@temp = split(' ',$rec);
	$noise_hash_5{"$temp[0] $temp[3] $temp[7] $temp[8]"} = "$temp[6]";
}

close (INFILEREALDATA);
close (INFILENOISEDATA_1);
close (INFILENOISEDATA_2);
close (INFILENOISEDATA_3);
close (INFILENOISEDATA_4);
close (INFILENOISEDATA_5);

$i=localtime();
# calculating time taken
($user_t,$system_t,$cuser_t,$csystem_t) = times;

print OUTFILEDATA "\# Version: $ver\n";
print OUTFILEDATA "\# Time: $i\n\n";
print OUTFILEDATA "\# Runtime details after preparing all hashes:\n";
print OUTFILEDATA "\# System time for process: $system_t\n";
print OUTFILEDATA "\# User time for process: $user_t\n\n";

print OUTFILESTATS "\# Version: $ver\n";
print OUTFILESTATS "\# Time: $i\n\n";
print OUTFILESTATS "\# Runtime details after preparing all hashes:\n";
print OUTFILESTATS "\# System time for process: $system_t\n";
print OUTFILESTATS "\# User time for process: $user_t\n\n";

print STDERR "\# Runtime details after preparing all hashes:\n";
print STDERR "\# System time for process: $system_t\n";
print STDERR "\# User time for process: $user_t\n\n";

# initializing variables for statistics
$count_u=$total_u=$conf_u=$count_d=$total_d=$conf_d=0;


#filling up the @merged_table array the merged file
# @real_table
# fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Category, Avg. dist., Std. dev.
# R=424	72	120	R=437	67	346	2	+	4512	2699.49
# 0	1	2	3	4	5	6	7	8	9

# @merged_table:fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Occurence conf., Avg. Rand Coin., Avg. Rand Coin. conf., Diff, Diff conf., Category, Avg. dist., Std. dev.

$ctr=0;
foreach $i (@real_table){
	
	$merged_table[$ctr][0] = $i->[0];# fam1
	$merged_table[$ctr][1] = $i->[1];# fam1-count
	$merged_table[$ctr][2] = $i->[2];# fam1-avg len
	$merged_table[$ctr][3] = $i->[3];# fam2
	$merged_table[$ctr][4] = $i->[4];# fam2-count
	$merged_table[$ctr][5] = $i->[5];# fam2-avg len
	$merged_table[$ctr][6] = $i->[6];# Occurence count
	
	# calculating occ. conf
	if($i->[1] > $i->[4]){
		$merged_table[$ctr][7] = &round2($i->[6]/$i->[4]);
	}
	elsif($i->[4] > $i->[1]){
		$merged_table[$ctr][7] = &round2($i->[6]/$i->[1]);
	}
	else{#both are equal, same family relation??
		$merged_table[$ctr][7] = &round2($i->[6]/$i->[1]);
	}

	
	# Avg Rand Coin. count
	#get the noise data
	$j=$k=0;
	#check if the relation even exists in noise 1
	if (exists $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 2
	if (exists $noise_hash_2{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_2{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 3
	if (exists $noise_hash_3{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_3{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 4
	if (exists $noise_hash_4{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_4{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}

	#check if the relation even exists in noise 5
	if (exists $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"}){
		$j += $noise_hash_1{"$i->[0] $i->[3] $i->[7] $i->[8]"};
		$k++;
	}
	
	# Random Coincidence
	if ($k>0){ # rand coin value found
		# Avg Rand Coin. count
		$merged_table[$ctr][8] = ceil($j/$k);
	
		# calculating Avg Rand Coin. conf
		if($i->[1] > $i->[4]){
			$merged_table[$ctr][9] = &round2($merged_table[$ctr][8]/$i->[4]);
		}
		elsif($i->[4] > $i->[1]){
			$merged_table[$ctr][9] = &round2($merged_table[$ctr][8]/$i->[1]);
		}
		else{#both are equal, same family relation??
			$merged_table[$ctr][9] = &round2($merged_table[$ctr][8]/$i->[1]);
		}
	}
	else{ # no rand coin values found
		$merged_table[$ctr][8] = 0;# Avg Rand Coin. count
		$merged_table[$ctr][9] = 0.00;# Avg Rand Coin. conf
	}
	
	#Diff
	#in order to store only >= 0 values
	if($i->[6] - $merged_table[$ctr][8] > -1) {
		$merged_table[$ctr][10] = $i->[6] - $merged_table[$ctr][8];
	}
	else{
		$merged_table[$ctr][10] = 0;
	}

	# calculating Diff. conf
	if ($merged_table[$ctr][10] > 0){# to avoid divide by 0
# 		$merged_table[$ctr][11] = &round2($merged_table[$ctr][10]/$i->[1]);
		if($i->[1] > $i->[4]){
			$merged_table[$ctr][11] = &round2($merged_table[$ctr][10]/$i->[4]);
		}
		elsif($i->[4] > $i->[1]){
			$merged_table[$ctr][11] = &round2($merged_table[$ctr][10]/$i->[1]);
		}
		else{#both are equal, same family relation??
			$merged_table[$ctr][11] = &round2($merged_table[$ctr][10]/$i->[1]);
		}
	}
	else{
		$merged_table[$ctr][11] = 0.00;# Diff. conf
	}
	
	$merged_table[$ctr][12] = $i->[7];# Category
	$merged_table[$ctr][13] = $i->[8];# Avg. dist.
	$merged_table[$ctr][14] = $i->[9];# Std. dev.
	
	# get info for statistics
	if($merged_table[$ctr][12] eq "U"){
		$count_u++;
		$total_u+=$merged_table[$ctr][10];
		$conf_u+=$merged_table[$ctr][11];
	}
	elsif($merged_table[$ctr][12] eq "D"){
		$count_d++;
		$total_d+=$merged_table[$ctr][10];
		$conf_d+=$merged_table[$ctr][11];
	}
	
	$ctr++; # increment for next record
}


#sort @merged_table on difference conf, difference
# @merged_table:fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen, Occurence, Occurence conf., Avg. Rand Coin., Avg. Rand Coin. conf., Diff, Diff conf., Category, Avg. dist., Std. dev.
@temp = sort {($b->[11] <=> $a->[11]) or ($b->[10] <=> $a->[10])} @merged_table;
@merged_table=@temp;


#print data to file
print OUTFILEDATA "\#Output sorted on difference conf and difference\n\n";
print OUTFILEDATA "\#fam1, Category, fam2, Occ, Occ conf, Avg Rand Coin, Avg Rand Coin conf, Diff, Diff conf, Avg Dist, Std Dev, fam1, fam1-count, fam1-avglen, fam2, fam2-count, fam2-avglen\n";


foreach $i (@merged_table){
	print OUTFILEDATA "$i->[0]\t$i->[12]\t$i->[3]\t$i->[6]\t$i->[7]\t$i->[8]\t$i->[9]\t";
	print OUTFILEDATA "$i->[10]\t$i->[11]\t$i->[13]\t$i->[14]\t$i->[0]\t$i->[1]\t";
	print OUTFILEDATA "$i->[2]\t$i->[3]\t$i->[4]\t$i->[5]\n";
}

# calculating time taken
($user_t,$system_t,$cuser_t,$csystem_t) = times;
print OUTFILEDATA "\n\# Runtime details after printing the relationships: \n";
print OUTFILEDATA "\# System time for process: $system_t\n";
print OUTFILEDATA "\# User time for process: $user_t\n";


#print stats to file
print OUTFILESTATS "NOTE: All avg. statistics are for the diff. counts and conf's\n\n";
print OUTFILESTATS "NOTE: Stats are not calculated for CONT rels because it is same as Within\n\n";
print OUTFILESTATS "Relationship type: U\n";
print OUTFILESTATS "Number of family pairs:\t".$count_u."\n";
if ($count_u > 0){
	print OUTFILESTATS "Average count:\t\t".ceil($total_u/$count_u)."\n";
	print OUTFILESTATS "Average confidence :\t".&round2($conf_u/$count_u)."\n";
}
print OUTFILESTATS "Relationship type: D\n";
print OUTFILESTATS "Number of family pairs:\t".$count_d."\n";
if ($count_d > 0){
	print OUTFILESTATS "Average count:\t\t".ceil($total_d/$count_d)."\n";
	print OUTFILESTATS "Average confidence :\t".&round2($conf_d/$count_d)."\n";
}

print OUTFILESTATS "\n\n\n********************************************************\n\n";

# calculating time taken
($user_t,$system_t,$cuser_t,$csystem_t) = times;
print OUTFILESTATS "\n\# Runtime details after printing the itemsets: \n";
print OUTFILESTATS "\# System time for process: $system_t\n";
#print OUTFILEDATA "\# System time for children: $csystem_t\n";
print OUTFILESTATS "\# User time for process: $user_t\n";
#print OUTFILEDATA "\# User time for children: $cuser_t\n";



print STDERR "\# Runtime details after printing the itemsets: \n";
print STDERR "\# System time for process: $system_t\n";
print STDERR "\# User time for process: $user_t\n";
print STDERR "NOTE: Stats are not calculated for CONT rels because it is same as Within\n\n";

close (OUTFILEDATA);
close (OUTFILESTATS);

exit;
